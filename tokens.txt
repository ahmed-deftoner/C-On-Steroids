calculateFib TOKEN_IDENTIFIER
: TOKEN_COLON
int TOKEN_INT
<- TOKEN_FUNCARROW
function TOKEN_FUNCTION
( TOKEN_OPENPARANTHESIS
n TOKEN_VARIABLE
: TOKEN_COLON
int TOKEN_INT
) TOKEN_CLOSEPARANTHESIS
{ TOKEN_BLOCKOPEN
x TOKEN_VARIABLE
: TOKEN_COLON
int TOKEN_INT
= TOKEN_EQUALSIGN
0 TOKEN_NUMBER
; TOKEN_SEMICOLON
y TOKEN_VARIABLE
: TOKEN_COLON
int TOKEN_INT
= TOKEN_EQUALSIGN
0 TOKEN_NUMBER
; TOKEN_SEMICOLON
z TOKEN_VARIABLE
: TOKEN_COLON
int TOKEN_INT
; TOKEN_SEMICOLON
if TOKEN_IF
( TOKEN_OPENPARANTHESIS
n TOKEN_IDENTIFIER
lt TOKEN_LESS
0 TOKEN_NUMBER
) TOKEN_CLOSEPARANTHESIS
then TOKEN_THEN
{ TOKEN_BLOCKOPEN
displayline TOKEN_DISPLAYLINE
: TOKEN_COLON
negative number entered TOKEN_STRING
; TOKEN_SEMICOLON
return TOKEN_RETURN
: TOKEN_COLON
0 TOKEN_NUMBER
; TOKEN_SEMICOLON
} TOKEN_BLOCKCLOSE
else TOKEN_ELSE
if TOKEN_IF
( TOKEN_OPENPARANTHESIS
n TOKEN_IDENTIFIER
eq TOKEN_EQUAL
0 TOKEN_NUMBER
) TOKEN_CLOSEPARANTHESIS
then TOKEN_THEN
{ TOKEN_BLOCKOPEN
displayline TOKEN_DISPLAYLINE
: TOKEN_COLON
it's 0 man! TOKEN_STRING
return TOKEN_RETURN
: TOKEN_COLON
0 TOKEN_NUMBER
; TOKEN_SEMICOLON
} TOKEN_BLOCKCLOSE
else TOKEN_ELSE
{ TOKEN_BLOCKOPEN
display TOKEN_DISPLAY
: TOKEN_COLON
\nThe fibonacci series:  TOKEN_STRING
; TOKEN_SEMICOLON
i TOKEN_VARIABLE
: TOKEN_COLON
int TOKEN_INT
= TOKEN_EQUALSIGN
1 TOKEN_NUMBER
; TOKEN_SEMICOLON
do TOKEN_DO
until TOKEN_UNTIL
( TOKEN_OPENPARANTHESIS
i TOKEN_VARIABLE
- TOKEN_MINUS
1 TOKEN_NUMBER
e TOKEN_IDENTIFIER
n TOKEN_VARIABLE
) TOKEN_CLOSEPARANTHESIS
{ TOKEN_BLOCKOPEN
display TOKEN_DISPLAY
: TOKEN_COLON
x TOKEN_IDENTIFIER
, TOKEN_COMMA
  TOKEN_STRING
; TOKEN_SEMICOLON
z TOKEN_VARIABLE
= TOKEN_EQUALSIGN
x TOKEN_VARIABLE
+ TOKEN_PLUS
y TOKEN_VARIABLE
; TOKEN_SEMICOLON
x TOKEN_VARIABLE
= TOKEN_EQUALSIGN
y TOKEN_VARIABLE
; TOKEN_SEMICOLON
y TOKEN_VARIABLE
= TOKEN_EQUALSIGN
z TOKEN_VARIABLE
; TOKEN_SEMICOLON
i TOKEN_VARIABLE
= TOKEN_EQUALSIGN
i TOKEN_VARIABLE
+ TOKEN_PLUS
1 TOKEN_NUMBER
; TOKEN_SEMICOLON
} TOKEN_BLOCKCLOSE
} TOKEN_BLOCKCLOSE
return TOKEN_RETURN
: TOKEN_COLON
0 TOKEN_NUMBER
; TOKEN_SEMICOLON
} TOKEN_BLOCKCLOSE
main TOKEN_IDENTIFIER
: TOKEN_COLON
int TOKEN_INT
<- TOKEN_FUNCARROW
function TOKEN_FUNCTION
( TOKEN_OPENPARANTHESIS
) TOKEN_CLOSEPARANTHESIS
{ TOKEN_BLOCKOPEN
num TOKEN_VARIABLE
: TOKEN_COLON
int TOKEN_INT
; TOKEN_SEMICOLON
Enter the number TOKEN_STRING
: TOKEN_COLON
read TOKEN_READ
: TOKEN_COLON
num TOKEN_VARIABLE
; TOKEN_SEMICOLON
result TOKEN_VARIABLE
: TOKEN_COLON
int TOKEN_INT
= TOKEN_EQUALSIGN
execute TOKEN_IDENTIFIER
calculateFib TOKEN_IDENTIFIER
( TOKEN_OPENPARANTHESIS
num TOKEN_VARIABLE
) TOKEN_CLOSEPARANTHESIS
return TOKEN_RETURN
: TOKEN_COLON
0 TOKEN_NUMBER
; TOKEN_SEMICOLON
} TOKEN_BLOCKCLOSE
 END_OF_FILE
